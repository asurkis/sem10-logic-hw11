\section{Задача 5}
Выполните предыдущее задание, не расширяя алфавит новыми символами.

\subsection{Решение}
Считаем, что пустой символ --- $O$, т.к.
нам достаточно всего двух символов.
Если это не так, то просто добавим для $O$
такие же переходы, как для пустого символа.

Тогда на сайте \url{https://turingmachinesimulator.com/}
описанием нужной машины Тьюринга будет следующий код:
\begin{verbatim}
name: Unary subtraction
init: leftmost
accept: qfin

leftmost,_
qfin,_,-

leftmost,S
seekRight1,S,>

seekRight1,S
seekRight1,S,>

seekRight1,_
seekRight2,_,>

seekRight2,S
seekRight3,S,>

seekRight2,_
seekFin1,_,<

seekRight3,S
seekRight3,S,>

seekRight3,_
seekLeft1,_,<

seekLeft1,S
seekLeft2,_,<

seekLeft2,S
seekLeft2,S,<

seekLeft2,_
seekLeft3,_,<

seekLeft3,S
seekLeft3,S,<

seekLeft3,_
seekLeft4,_,>

seekLeft4,S
leftmost,_,>

seekFin1,_
seekFin2,_,<

seekFin2,S
seekFin2,S,<

seekFin2,_
qfin,_,>
\end{verbatim}

То есть сначала мы находимся в самой левой ненулевой ячейке первого числа,
ищем самую правую ненулевую ячейку второго числа.

Если такой нет (т.е. второе число --- 0),
то переходим до самой левой ячейки первого
числа, и первое число будет ответом.

Если такая есть, то зануляем её, ищем самую левую ненулевую
ячейку первого числа, зануляем её, и переходим на 1 вправо,
оба числа уменьшены на 1, мы принимаем вход заново.

Если первое число оказалось нулём, считаем,
что второе также будет нулём.

% name: Unary subtraction
% init: qinit
% accept: qfin

% qinit,O
% qfin,O,

% qinit,0
% qinit,0,>

% qinit,1
% qinit,1,>

% qinit,2
% qinit,2,>

% qinit,3
% qinit,3,>

% qinit,4
% qinit,4,>

% qinit,5
% qinit,5,>

% qinit,6
% qinit,6,>

% qinit,7
% qinit,7,>

% qinit,8
% qinit,8,>

% qinit,9
% qinit,9,>

% qinit,_
% halve,0,<

% // Halve and go to addHalf to add the goBack
% halve,0
% halve,0,<

% halve,1
% addHalf,0,>

% halve,2
% halve,1,<

% halve,3
% addHalf,1,>

% halve,4
% halve,2,<

% halve,5
% addHalf,2,>

% halve,6
% halve,3,<

% halve,7
% addHalf,3,>

% halve,8
% halve,4,<

% halve,9
% addHalf,4,>

% // Add 0.5 to the right
% addHalf,0
% jump,5,<

% addHalf,1
% jump,6,<

% addHalf,2
% jump,7,<

% addHalf,3
% jump,8,<

% addHalf,4
% jump,9,<

% // Jump back
% jump,0
% halve,0,<

% jump,1
% halve,1,<

% jump,2
% halve,2,<

% jump,3
% halve,3,<

% jump,4
% halve,4,<

% // If we halved successfully, we first remove the zero if there is one and then we go back
% halve,_
% removezero,_,>

% removezero,0
% removezero,_,>

% removezero,1
% goBack,1,>

% removezero,2
% goBack,2,>

% removezero,3
% goBack,3,>

% removezero,4
% goBack,4,>

% removezero,5
% goBack,5,>

% removezero,6
% goBack,6,>

% removezero,7
% goBack,7,>

% removezero,8
% goBack,8,>

% removezero,9
% goBack,9,>

% // qfinished
% removezero,_
% qfin,_,>

% // normal goBack
% goBack,0
% goBack,0,>

% goBack,1
% goBack,1,>

% goBack,2
% goBack,2,>

% goBack,3
% goBack,3,>

% goBack,4
% goBack,4,>

% goBack,5
% goBack,5,>

% goBack,6
% goBack,6,>

% goBack,7
% goBack,7,>

% goBack,8
% goBack,8,>

% goBack,9
% goBack,9,>

% // rest
% goBack,_
% rest,_,<

% rest,0
% rest0,_,>

% rest0,_
% setrest0,_,>

% rest,5
% rest1,_,>

% rest1,_
% setrest1,_,>

% setrest0,0
% setrest0,0,>

% setrest0,1
% setrest0,1,>

% setrest1,0
% setrest1,0,>

% setrest1,1
% setrest1,1,>

% setrest0,_
% continue,0,<

% setrest1,_
% continue,1,<

% // continue
% continue,0
% continue,0,<

% continue,1
% continue,1,<

% continue,_
% continue2,_,<

% // delimiter
% continue2,_
% halve,0,<
